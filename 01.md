## 第1课

##### 国际惯例之'Hello, world!'
介绍一下Linux系统调用表。在这一节课中我们将使用软件中断从内核中请求系统函数并在终端中打印出'Hello World!'.

---

## 第1课

#### Hello, world!

##### 基础知识

汇编语言是最基本的。程序员在实际硬件上也就只有内核了。为了用汇编写一些有用的程序，我们需要使用内核提供的Linux系统调用。这些系统调用是一个内置在操作系统里用于提供功能的库，比如从键盘读取输入、将输出打印在屏幕上。

When you invoke a system call the kernel will immediately suspend execution of your program.  It will then contact the necessary drivers needed to perform the task you requested on the hardware and then return control back to your program.


Note:


Drivers are called _drivers_ because the kernel literally uses them to drive the hardware.


We can accomplish this all in assembly by loading EAX with the function number (operation code OPCODE) we want to execute and filling the remaining registers with the arguments we want to pass to the system call. A software interrupt is requested with the INT instruction and the kernel takes over and calls the function from the library with our arguments. Simple.

For example requesting an interrupt when EAX=1 will call sys_exit and requesting an interrupt when EAX=4 will call sys_write instead. EBX, ECX & EDX will be passed as arguments if the function requires them. [Click here to view an example of a Linux System Call Table and its corresponding OPCODES.](http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html)

##### Writing our program

Firstly we create a variable 'msg' in our .data section and assign it the string we want to output in this case 'Hello, world!'. In our .text section we tell the kernel where to begin execution by providing it with a global label _start: to denote the programs entry point.

We will be using the system call sys_write to output our message to the console window.  This function is assigned OPCODE 4 in the Linux System Call Table.  The function also takes 3 arguments which are sequentially loaded into EDX, ECX and EBX before requesting a software interrupt which will perform the task.

The arguments passed are as follows:


* EDX will be loaded with the length (in bytes) of the our string.

* ECX will be loaded with the address of our variable created in the .data section.

* EBX will be loaded with the file we want to write to – in this case STDOUT.

The datatype and meaning of the arguments passed can be found in the function's definition.

We compile, link and run the program using the commands below.


helloworld.asm
```asm
; Hello World Program - asmtutor.com
; Compile with: nasm -f elf helloworld.asm
; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld
; Run with: ./helloworld

SECTION .data
msg     db      'Hello World!', 0Ah     ; assign msg variable with your message string

SECTION .text
global  _start

_start:

    mov     edx, 13     ; number of bytes to write - one for each letter plus 0Ah (line feed character)
    mov     ecx, msg    ; move the memory address of our message string into ecx
    mov     ebx, 1      ; write to the STDOUT file
    mov     eax, 4      ; invoke SYS_WRITE (kernel opcode 4)
    int     80h
```

```bash
~$ nasm -f elf helloworld.asm
~$ ld -m elf_i386 helloworld.o -o helloworld
~$ ./helloworld
Hello World!
Segmentation fault
```

Error:
Segmentation fault
